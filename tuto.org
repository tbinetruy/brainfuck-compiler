#+TITLE: Learning LISP by making a Brainfuck compiler
#+Author: Thomas Bin√©truy
#+INCLUDE: "print/doctype-memo.org"
{{{subtitle(Equisafe)}}}
{{{date(July 2018)}}}
{{{theme-color(19cba9)}}}

Most of the time, hackers at Yourlabs work on useful stuff. Today however, I was bored and decided to lisp a bit by making what is probably the most useless program ever: a brainfuck compiler targeting a custom virtual machine. We'll first look into Brainfuck, how it works, and how it can be used to write small programs. We then develop a small virtual machine and a Brainfuck compiler targeting it.

* Part I: Introduction to Brainfuck
   
Let us first understand what Brainfuck is about. The basic idea is that we have a heap at out disposal, represented as a list of integers, and a pointer to an entry in the list. We can navigate this heap in Brainfuck by moving the pointer around it by incrementing or decrementing it. Finally, we can output to ~stdout~ the heap entry that is currently being pointed to by converting it to its associated ASCII character. Before introducing the looping mechanism offered by Brainfuck, let us go over the syntax for the concepts we have just discussed:

- ~<~: decrement the heap pointer
- ~>~: increment the heap pointer
- ~+~: increment the heap entry being pointed to by the heap pointer
- ~-~: decrement the heap entry being pointed to by the heap pointer
- ~.~: output as ASCII to stdout the heap entry being pointed to by the heap pointer.

As an example, if we begin with a heap of length ten with each entries set to 0 and want to set it to ~[1, 2, 3, 0, 0, ...]~, we could write the following Brainfuck program:

#+begin_src
+>++>+++
#+end_src

Let's compile this Brainfuck program and run it through our VM we will program in this article:

#+begin_src emacs-lisp :session tuto
(load-file "./vm.el")
(load-file "./bf-compiler.el")
#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp :exports both :session tuto
(setq src "+>++>+++")
(vm//main (compiler//compile src t))
#+end_src

#+RESULTS:
| (1 2 3 0 0 0 0 0 0 0) |
   
As we can see, the heap's end state is indeed a list of zeros with the three first elements set to the first three natural numbers.

Let us now introduce Brainfuck's looping mechanism. We surround a number of instructions to iterate over with ~[~ and ~]~, the loop will execute the instruction block until the value pointed to by the heap pointer equals zero when beginning the next iteration. The following snippet implements an addition, in this case ~3 + 3~, by making use of a simple loop:

#+begin_src emacs-lisp :exports both :session tuto
(vm//main (compiler//compile "+++>+++<[->+<]" t))
#+end_src

#+RESULTS:
| (0 6 0 0 0 0 0 0 0 0) |

We get the correct result by initiating the heap to ~(3 3 0 ...)~ before the loop start, then subtract one from the first heap entry and add it to the second until the first entry vanishes. As an exercise, you could modify our addition function to have the result in the first heap entry rather than the second ;)

** Hello World

Let us now conclude this Brainfuck tutorial by making a Hello World program. In this first snippet, we increment the first heap entry until 32 in order to "cache" the space character which we'll need later. We then increment the heap pointer and start printing characters to ~stdout~ by incrementing or decrementing the current heap entry with ~+~ or ~-~ and printing it with ~.~. We therefore start with 72 plus signs corresponding to the letter 'H'. We then decrement by 3 and output 'E' /etc/. Once at the end of "HELLO", we decrement the heap pointer and output the space character we needed. We increment back the heap pointer and continue outputting "WORLD". We could have used a single heap entry to output our words, but reserving the first entry for special chars and the second for letters saves us from having to decrement from 79 ('O') to 32 (' ') back to 87 ('W'). It's also funner :)

#+begin_src emacs-lisp :exports both :session tuto
(vm//main (compiler//compile "++++++++++++++++++++++++++++++++>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.---.+++++++..+++.<.>++++++++.--------.+++.------.--------." t))
#+end_src

#+RESULTS:
| HELLO WORLD | (32 68 0 0 0 0 0 0 0 0) |

Bellow is a different hello world that I found on the Wikipedia entry. Notice that it is both shorter and more complex than the previous example. In particular, it uses more memory but uses loops to save up on ~+~ and ~-~ signs. So mysterious:

#+begin_src emacs-lisp :exports both :session tuto
  (setq src "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.")
  (vm//main (compiler//compile src t) nil) ; "prints Hello World!"
#+end_src

#+RESULTS:
| Hello World! | (0 0 72 100 87 33 10 0 0 0) |

* Part II: virtual machine boilerplate

Our brainfuck compiler will target a virtual machine that we'll design in this section. It'll teach us a bit about bytecode, and is a good exercise to learn a bit about Lisp and computers in general as our bytecode will resemble in some ways to Assembly.

From an abstract point of view, our virtual machine will be a program that takes a /list of instructions/ that can operate on a /stack/ and a /heap/. We'll also implement /registers/ that can be used for various counters, such as the /program counter/, which allows the VM to keep track of which instructions is currently being executed. 

Let's get coding! There are a few Lisp concepts to go over, but we will learn about them as we code. The snippet bellow declares a function ~vm//main~ that takes a list of instructions as first argument and an optional ~log~ boolean which we'll use to see what is going on in our VM as it executes code.

#+begin_src emacs-lisp :session code
; function declaration
(defun vm//main (instructions &optional log)
  ; Variable declarations
  (let ((stack '())  ; The initial stack is an empty list
        (registers (list (cons 'pc  0))))  ; Registers are list of cons. Here, there
                                           ; is only 1 register, the program counter
    ; Iteration over instruction set until program counter is 
    ; greater then the instruction set length
    (while (< (alist-get 'pc registers) (length instructions))
      ; Variable declarations: the current instruction obtained 
      ; using the program counter is stored. We then parse the
      ; instruction and its argument and store them.
      (let* ((instruction (nth (alist-get 'pc registers) instructions))
             (key (nth 0 instruction))  
             (val (nth 1 instruction)))
        ; Case matching and handling of current instruction
        (if (equal key "PUSH")
            ; Update stack variable with mutate stack returned 
            ; by the function`vm//push`
            (setq stack (vm//push stack val)))
        (if (equal key "ADD")
            (setq stack (vm//op stack '+)))
        (if (equal key "SUB")
            (setq stack (vm//op stack '-)))

        ; ...
        ; Add additional cases here
        ; ...

        ; Log stack current instruction, stack and registers
        ; if necessary
        (if log
            (message "%s %s %s" instruction stack registers)))
      ; Increment the program counter and end the current iteration
      (vm//increment-pc registers 1))
    ; Return the registers and final stack states
    `(,stack ,registers)))
#+end_src

#+RESULTS:
: vm//main

As you can see, we use the keyword ~defun~ in Elisp to declare a function. Its first argument is the function's name, the second a list of arguments - two in our case, with an optional one -, and ~n~ more expressions that will execute sequentially and return the last expression executed by the function.

In this function, we first declare a stack as an empty list using ~'()~ in the ~let~ macro (we'll go over them in a bit!). This macro takes a list of assignments as first argument and an expression as a second argument. The variables declared will be available from the code passed as second argument to ~let~ when it executes. We also define our registers as a ~list~ of ~cons~ (which you can view as a tuple of length two) where the first element is the key and the second the value for that key. In Lisp, this is called an /associative list/, or ~alist~, and can be viewed as a Python dictionary. Hence our registers are a simple /key->value/ store with the key being the register name and the value, the value stored at that register. We only define a single register for now, called ~pc~ for /program counter/.

We can now iterate over the list of instructions using ~while~ until the program counter, incremented at each iteration, grows larger than the length of the instruction list. We use a special variant of ~let~ to parse the instruction: ~let*~. The difference with the former is subtle: without the ~*~, we cannot have the variables refer to each other sequentially in the first argument for ~let~ (the definitions). Here however, we get the element from the instruction list pointed to by the program counter (with ~(nth (alist-get 'pc registers) instructions)~) and then use this value to declare the variables ~key~ and ~value~ which correspond to the instruction name and its argument respectively. Had we not used ~let*~, we'd have to use two nested ~let~ expressions.

Finally, we do case matching on the instruction name, execute it, and increment the program counter.

At this point, you've probably wondered why are there quotes sprinkled all over our lisp code, and it's time to understand this syntax. As you can see, our Lisp code consists of nested expressions of the form ~(exp-name exp-arg-1 exp-arg-2 ... exp-arg-n)~ that will /evaluate/ and return other expressions. There are rules to the evaluations of expressions and in particular, when evaluating a function, all its arguments are evaluated first, and then passed to the function body for further use. The quote symbol we've been using is actually a lisp shorthand (hard coded in the elisp reader but usually implemented as a "reader macro", which elisp does not support if my memory does not fail me) for the ~quote~ macro, therefore ~'some-exp == (quote (some-exp))~. Unlike functions, macros do not evaluate their arguments when executing allowing them to be used to *manipulate* code, we'll dive into macros shortly. But sometimes, you want to pass un-evaluated arguments to a function, and in this case /quote/ the argument. This is what is been done when declaring a ~cons~ cell in the above snippet, and when calling ~alist-get~ for getting an alist's entry for a specific register. In both cases ~pc~ needs to be quoted as it is not available in the scope (either as a function, variable, macro or whatever) and hence would throw. By quoting it we actually pass the /symbol/, ~pc~, to ~cons~ and ~alist-get~ by quoting it with ~'pc~. Think of it this way: if we are not evaluating a variable that is not defined, then there is no problem, we just associate it a symbol and pass that symbol around :) Last but not least, this means that the quote can be used to get a list. Indeed, evaluating ~(1 2 3)~ will look for a function or macro called ~1~ and evaluate it with arguments ~2~ and ~3~; whereas ~'(1 2 3)~ (or equivalently, ~(quote (1 2 3))~) will return a /list/ with elements ~1~, ~2~, and ~3~. It may seem complex at first, and quiet frankly, I haven't completely grasped it myself (please help me out if I'm wrong ;)), but you'll get it as we start coding some more!

Let's now go over the ~PUSH~ instruction. We call it from ~vm//main~ with ~(vm//push stack val)~ and assign its result back to ~stack~ with ~setq~ which allows to modify a variable that was defined in a ~let~ or ~let*~ block. As you can see, pushing onto a list is very easy in elisp, we simply make use of the default ~push~ macro.

#+begin_src emacs-lisp :session code
(defun vm//push (stack val)
  (push val stack))
#+end_src

#+RESULTS:
: vm//push

Now, the ~ADD~ instruction. Since ~SUB~, ~MUL~ and ~DIV~ work similarly, we have factored the logic into a function ~vm//op~ which we call by passing the lisp functions ~+~, ~-~ , ~*~ and ~/~. What this function does is that it pops two elements off the stack and applies the function passed as the first argument to them and pushes the result back on the stack. We apply arguments to a function using ~funcall~:

#+begin_src emacs-lisp :session code
(defun vm//op (stack op)
  (push (funcall op (pop stack) (pop stack)) stack))
#+end_src

#+RESULTS:
: vm//op

The ~ADD~ instruction is then implemented as ~(vm//op stack '+)~ where we pass the ~+~ function symbol by quoting it, preventing its execution, as a second argument.

The ~vm//increment-pc~ function increments by a value passed as argument the ~pc~ register. Setting the ~pc~ is a bit tricky: we want to set the second element of the key-value pair corresponding to ~pc~ in the registers alist. We do this using ~setcdr~ on ~(assq 'pc registers)~ with ~val~. Concretely, a con's (tuple of length two) ~car~ and ~cdr~ are it's first and second element respectively. We can modify the con's second element by calling ~setcdr~ on it. Here what we're trying to do is find the cons corresponding to the program counter in the ~registers~ alist, and set its ~cdr~ to the new value. We can get a pointer to this cons using ~assq~ which takes a key, ~'pc~, as first argument to look into the alist provided by the second argument, ~registers~.

#+begin_src emacs-lisp :session code
(defun vm//set-pc (registers val)
  (setcdr (assq 'pc registers) val))
#+end_src

#+RESULTS:
: vm//set-pc

We can now make use of ~vm//set-pc~ to implement ~vm//increment-pc~ which will increment our program counter, this function speaks for itself but parsing it if you've never lisped much before can take some time:

#+begin_src emacs-lisp :session code
(defun vm//increment-pc (registers val)
  (vm//set-pc registers (+ (alist-get 'pc registers) val)))
#+end_src

#+RESULTS:
: vm//increment-pc

Let's now try to add two numbers! All we need to do is ~PUSH~ the two numbers on the stack and call ~ADD~:

#+begin_src emacs-lisp :exports both :session code
(vm//main '(("PUSH" 10)
            ("PUSH" 20)
            ("ADD")))
#+end_src

#+RESULTS:
|       30 |
| (pc . 3) |

As you can see, we have the correct output of 30 and our final program counter value is 3, as expected since we only have three instructions to run.

* Part III: Compiling a Brainfuck subset to our VM's bytecode

Now that we've learned how Brainfuck works and have our small VM working, we can start compiling a first set of Brainfuck instructions to our bytecode. We'll need to make some modifications to our VM: add a heap and a heap pointer since that's how brainfuck works. Then, we'll be able to easily compile the ~+~, ~-~ , ~<~ and ~>~ instructions. The important takeaway here is that we now have two registers, one to track which instruction we are currently executing and another to identify where in the heap we are currently located at. We'll also need to add instructions to mutate the heap or else it would be of no use.

** VM modifications
    
We'll add on top of our VM's stack and registers, some RAM used as our head and initialized as a list of zeros using ~make-list~. We'll also add the ~READ_RAM~ and ~WRITE_RAM~ instructions to interact with the VM's RAM. Finally, we need three new registers: ~eax~, ~ebx~ and ~ecx~ which essentially gives our VM three global variables. ~eax~ and ~ebx~ will be used by some VM instructions such as ~WRITE_RAM~ which reads the value to write in ~ebx~ and the location to write to as ~eax~. We could implement ~WRITE_RAM~ only on the stack by popping the two top stack frames and acting upon them, but I have chosen to implement them as registers not only to mimic the way system calls work on Linux but also and mostly because it's fun. However, our compiler will use the ~ecx~ register to store the heap pointer since we need to store it somewhere.

An other way to implement the heap pointer would be by implementing a stack pointer that would allow us to move around the stack. We could then store the heap pointer (and any other variables) by pushing it on the stack and recovering it at any time by moving the stack pointer back to the variable location. This is how variables can be implemented on a compiler for the Tezos blockchain virtual machine which allows moving the /instruction pointer/ (/i.e./ the stack pointer) around with the ~DIP~ and ~IIP~ instructions ("decrement instruction pointer" and "increment instruction pointer").

# We also need two helpers to store and load a value from a register:

We first define two helpers that will allow us to easily store and read a value from a register. Starting with ~vm//store~ which takes a stack and a registers alist as argument, we simply generalize the work we did in ~vm//set-pc~. We'll use the stack to store the register name and its value by pushing them onto it, and pop them in ~vm//store~ to set the appropriate ~registers~ alist entry as in ~vm//set-pc~:

#+begin_src emacs-lisp :session code
(defun vm//store (stack registers)
  "Stores the second to top stack frame into the register referred
to by the top stack frame and pops these two value from the stack.
Ex: [S, new_val, register_name] -> [S]
    {R, register_name: old_val} -> {R, register_name: new_val}"
  (setcdr (assq (pop stack) registers) (pop stack))
  stack)
#+end_src

In the above docstring, we introduce a convenient notation allowing us to formalize the stack and register mutations by the function. ~[S, new_val, register_name]~ means "some stack with n elements and the top two elements being ~new_val~ and ~register_name~". ~{R, register_name: old_val}~ means "a set of registers ~R~ with an additional register ~register_name~ and value ~old_val~". The arrow, ~->~ indicates the transition of stack or register states before and after the function evaluates.

We should also also implement a function allowing us to ~load~ a register onto the stack. In the ~vm//load~ function bellow, we get the register name to retrieve by poping the stack, and we use ~cdr~ and ~assq~ to retrieve the associated register cons and getting its second entry (the register value):

#+begin_src emacs-lisp :session code
(defun vm//load (stack registers)
  "Pushes the content of the register referred to by
the top stack frame on the stack and pops the register
name.
Ex: [S, register_name] -> [S, registers[register_name]]"
  (push (cdr (assq (pop stack) registers)) stack))
#+end_src

#+RESULTS:
: vm//load

We then write to the ram address by reading from the register ~eax~ the address to write at, and from register ~ebx~ the new value. We have not yet seen how to edit a list ~nth~'s entry however. We need to dive into how lisps work a tiny bit in order to understand how to do that. In lisp, lists are essentially /linked lists/ constructed from /cons/. Each cons's /car/ is its value, and /cdr/ the address to the next con cell. Here's a little diagram that will help you out, they're taken from [1] and slightly modified for our needs, but I encourage you to go read [1] as it explains a lot about the inner workings of lisp ;)

[1] https://www.emacswiki.org/emacs/ListModification

#+begin_src

              +-------+-------+
 cons cell--->|  car  |  cdr  |
              +-------+-------+

         +-------+---+    +------+---+  +-------+-----+
 list--->| alpha | *----->| beta | *--->| gamma | nil |
         +-------+---+    +------+---+  +-------+-----+
              ^              ^     ^               ^
              |              |     |               |        
          con cell 1        car   cdr           list end

#+end_src

We can now understand how to access a list's element, what we want is similar to finding the /nth cdr/ of the list. Which is exactly why elisp has a function ~nthcdr~ available for us. But that will actually only give us the sub-list going from ~n~, so we want its first element, its ~car~ which we can set with ~setcar~. Hence, in lisp, setting a list's /nth/ element is done by /setting/ the ~car~ of the ~nthcdr~ of a list :)

Back to reading and writing our ram using registers. We'll have ~vm//write-ram~ read the ram address to write at register ~eax~ and the new value at register ~ebx~, we use this information to return an updated ram.

#+begin_src emacs-lisp :session code
(defun vm//write-ram (registers ram)
  "Stores a value at some ram address:
eax: ram address
ebx: value"
  (let ((addr (alist-get 'eax registers))
        (val (alist-get 'ebx registers)))
    (setcar (nthcdr addr ram) val))
  ram)
#+end_src

To spice it up a bit, we'll implement ~vm//read-ram~ by reading the address from register ~eax~ and /updating/ ~eax~ with that value, so the stack will not change when this function executes, only the content of the ~eax~ register! To do so, we set the desired register with ~setcdr~ and ~assq~ to the /nth/ entry in our ram, or in lisp words, the ~car~ of the ~nthcdr~ of the list. /n/ being the content of the ~eax~ register in our case:

#+begin_src emacs-lisp :session code
(defun vm//read-ram (registers ram)
  "Read value from ram. Return value in eax
eax: ram addr
return eax: value at ram addr"
  (let ((addr (alist-get 'eax registers)))
    (setcdr (assq 'eax registers) (car (nthcdr addr ram)))))
#+end_src

#+RESULTS:
: vm//read-ram

We can now add these new instructions to our virtual machine:

#+begin_src emacs-lisp :session code
(defun vm//main (instructions &optional log)
  (let ((stack '())
        (registers (list 
                    (cons 'eax  0)
                    (cons 'ebx  0)
                    (cons 'ecx  0)   ; heap pointer
                    (cons 'pc  0)))  ; program counter
        (ram (make-list 10 0)))
    (while (< (alist-get 'pc registers) (length instructions))
      (let* ((instruction (nth (alist-get 'pc registers) instructions))
             (key (nth 0 instruction))
             (val (nth 1 instruction)))
        (if (equal key "READ_RAM")
            (vm//read-ram registers ram))
        (if (equal key "WRITE_RAM")
            (setq ram (vm//write-ram registers ram)))
        (if (equal key "LOAD")
            (setq stack (vm//load stack registers)))
        (if (equal key "STORE")
            (setq stack (vm//store stack registers)))
        (if (equal key "PUSH")
            (setq stack (vm//push stack val)))
        (if (equal key "ADD")
            (setq stack (vm//op stack '+)))
        (if (equal key "SUB")
            (setq stack (vm//op stack '-)))
        (if log
            (message "%s %s %s" instruction stack registers)))
      (vm//increment-pc registers 1))
    `(,stack ,registers, ram)))
#+end_src

#+RESULTS:
: vm//main

Let's play with it for a bit :) In the snippet bellow, we push 5 to ~eax~ and 10 to ~ebx~ and call ~WRITE_RAM~ to store 10 at heap address 5. We also call ~READ_RAM~ which will write 10 to the ~eax~ register since this register contained 5 before calling the instruction meaning that the content of ~eax~, 5, will be replaced with the heap value at 5, which is 10. Note that we end up with an empty stack:

#+begin_src emacs-lisp :export both :session code
(vm//main '(("PUSH" 5)
            ("PUSH" eax)
            ("STORE")
            ("PUSH" 10)
            ("PUSH" ebx)
            ("STORE")
            ("WRITE_RAM")
            ("READ_RAM")))
#+end_src

#+RESULTS:
| nil | ((eax . 10) (ebx . 10) (pc . 8)) | (0 0 0 0 0 10 0 0 0 0) |

** Compiling

Finally, we can start compiling our Brainfuck instruction subset. The first thing we need is a /lexer/, which will tokenize Brainfuck code. It is a very simple lexer that just takes a string with no spaces and ouputs a list of characters making up the string:

#+begin_src emacs-lisp :export both :session code
(defun lexer//lex (code)
  (split-string code ""))

(lexer//lex "++++>+++++<[->+<]")
#+end_src

#+RESULTS:
| + | + | + | + | > | + | + | + | + | + | < | [ | - | > | + | < | ] |

Keep It Simple Stupid !

Let's now write some boilerplate for our compiler. We need a function that take some code as input and lexes it, we store the result in a variable ~tokens~ which we will iterate over. We also need an ~instructions~ variable which is initialized as an empty list and which will contain the bytecode representation of the Brainfuck code that will be ran through our VM. We also need a position counter called ~current-pos~ which will contain a pointer to the current ~token~ to compile. Note that this counter is /independent/ from the VM, it's simply used by the compiler to track which Brainfuck token it is currently compiling. We then iterate over the token list and process them (~+~, ~-~, ~<~ and ~>~).

To get us warmed up, let's define a function that returns some initialization code. We want to initialize the /heap pointer/ to zero. Remember that in Brainfuck, the goal is to move around the heap (our VM's RAM) and increment or decrement entries to compute something. We therefore need to /track/ this heap pointer somewhere in our VM, why not in the ~ecx~ register since it isn't used by our VM? So let's initialize the ~ecx~ register to zero:

#+begin_src emacs-lisp :session code
(defun compiler//init-code (instructions)
  "Initialize the program counter, stored in ecx, to 0."
  (push-instruction '("PUSH" 0))
  (push-instruction '("PUSH" ecx))
  (push-instruction '("STORE"))
  instructions)
#+end_src

We now define our compiler's main body, ~compiler//compile~, that takes some code as its only argument, and returns a list of bytecode instructions for our VM to execute. This function is in some ways very similar to ~vm//main~:

#+begin_src emacs-lisp :session code
(defun compiler//compile (code)
  "Compiles a Brainfuck code string."
  (let ((tokens (lexer//lex code))  ; Lex the code
        (instructions  ; bytecode start with our init code
         (compiler//init-code instructions))  
        (current-pos 0))  ; we start at the first token
    ; We iterate on the tokens
    (while (< current-pos (length tokens))
      ; We parse the token
      (let ((el (nth current-pos tokens)))
        (if (equal el ">")
            ; Call the appropriate function and update the 
            ; instructions with the result
            (setq instructions (compiler//increment-pc instructions 1)))
        (if (equal el "<")
            (setq instructions (compiler//increment-pc instructions -1)))
        (if (equal el "-")
            (setq instructions (compiler//increment-value instructions -1)))
        (if (equal el "+")
            (setq instructions (compiler//increment-value instructions 1))))
      ; We increment the current position
      (setq current-pos (1+ current-pos)))
    ; And return the final bytecode list
    instructions))
#+end_src

#+RESULTS:
: compiler//compile

We'll now implement a helper to push new instructions to the list of instructions representing the Brainfuck code. We implement this helper as a /macro/ using ~defmacro~ instead of ~defun~. A macro differs from a function in that it /does not evaluate/ its arguments, and it returns an /s-expression/ to be evaluated later. This macro takes an instruction as input and return an instruction that /concatenates/ this instruction to the list of instructions the compiler shall return. We implement this helper as a macro rather than a function to save us from passing list pointers around. Moreover, the assignment is now in the macro making code using this macro easier to read.

#+begin_src emacs-lisp :session code
(defmacro push-instruction (instr)
  `(setq instructions (nconc instructions (list ,instr))))
#+end_src

#+RESULTS:
: push-instruction

Let us first investigate how to increment the program counter, stored in ~ecx~. We first push the register on the stack, load its value, add unity to it, and store it back to ~ecx~:

#+begin_src emacs-lisp :session code
(defun compiler//increment-pc (instructions val)
  "Increments the value of the program counter by val.

It works as follows:
- Push the value of ecx (where the pc is stored) onto the stack
- Push val on the stack
- Call the add instruction
- Store the resulting value back into ecx"
  (push-instruction '("PUSH" ecx))
  (push-instruction '("LOAD"))

  (push-instruction `("PUSH" ,val))

  (push-instruction '("ADD"))

  (push-instruction '("PUSH" ecx))
  (push-instruction '("STORE")))
#+end_src

#+RESULTS:
: compiler//increment-pc

Incrementing a value pointed to in the heap by the heap pointer (stored in ~ecx~) is a little more complex. We first copy the heap pointer in ~ecx~ to ~eax~ and call ~READ_RAM~ to read the heap value now at ~eax~ (and ~ecx~). This stores the heap value at the heap pointer on ~eax~ which we then push on the stack allowing us to increment. We then store this new value by saving it to ~ebx~, copying the heap pointer (in ~ecx~) to ~eax~ again (since its first copy was overwritten by the ~READ_RAM~ instruction), and calling ~WRITE_RAM~ (which writes ~ebx~ at RAM address ~eax~).

#+begin_src emacs-lisp :session code
(defun compiler//increment-value (instructions val)
  "Increments by val the content of the address pointed at by the pc."
  ; Get the program counter from ecx and store it to eax.
  ; This is the address at which we want to increment the value.
  (push-instruction '("PUSH" ecx))
  (push-instruction '("LOAD"))
  (push-instruction '("PUSH" eax))
  (push-instruction '("STORE"))

  ; We then read from the ram at the address in eax (the pc)
  (push-instruction '("READ_RAM"))

  ; The value we read is now in eax, and we want to load it on the stack
  (push-instruction '("PUSH" eax))
  (push-instruction '("LOAD"))

  ; We can now add val to the value we pushed on the stack
  (push-instruction `("PUSH" ,val))
  (push-instruction '("ADD"))

  ; and store it back in ebx.
  (push-instruction '("PUSH" ebx))
  (push-instruction '("STORE"))

  ; Finally, we store the pc in eax again
  (push-instruction '("PUSH" ecx))
  (push-instruction '("LOAD"))
  (push-instruction '("PUSH" eax))
  (push-instruction '("STORE"))

  ; and call the store to ram syscall.
  (push-instruction '("WRITE_RAM"))
  instructions)
#+end_src

#+RESULTS:
: compiler//increment-value

Notice that the above snippet introduces us to the ~quasi-quote~ (the backquote, ~`~) which when applied to an S-expression evaluates none of its arguments but the ones "escaped" by the comma, ~,~. This is a very convenient way to create new lists as it allows us to evaluate some of its elements. Hence if ~val~ evaluates to 10, then ~`(foo ,val)~ will evaluate to the list ~(foo 10)~.

Let's run a simple example making use of the Brainfuck subset we have implemented in the compiler:

#+begin_src emacs-lisp :export both :session code
(vm//main (compiler//compile "+>++>+++<-"))
#+end_src

#+RESULTS:
| (eax . 1) | (ebx . 1) | (ecx . 1) | (pc . 133) |   |   |   |   |   |   |
|         1 |         1 |         3 |          0 | 0 | 0 | 0 | 0 | 0 | 0 |

As expected, the heap state we get is ~(1 1 3 0 ... 0)~ meaning that we have properly compiled these instructions. Notice that our VM's program counter is at 133, meaning that our compiler compiled 133 instructions from this brainfuck code! Surely, there are a few optimizations that we could easily make, but we'll let the motivated reader give it a try. One obvious optimization that comes to mind is to "compress" repeating characters at compile time. For instance, this code ~++++~ increments by 1 the heap value currently pointed to instead of simply adding five to it at once. A similar optimization can be made with the mutation of the heap pointer with ~<~ and ~>~.


* Part IV: Adding Brainfuck loops to our compiler
   
We'll now implement the Brainfuck's looping mechanism. This feature is crucial as without it, Brainfuck would not be a Turing complete language.

** VM modifications
    
We'll need to implement /jumps/ and /conditional statements/ in our VM. Indeed, Brainfuck's looping mechanism, introduced in Part I, requires to /jump/ back to the beginning of the loop block /only if/ the heap value at the location the heap pointer points to is not zero when the current iteration began. We'll implement the jump as a /relative/ jump simply by incrementing or decrementing the program counter.

The /if/ statement is a bit trickier: if the top stack frame is 0 (~False~), then increment the program counter by one additional unit which put on top of the VM's incrementation of the program counter after executing each instruction, means that a ~False~ statement will actually increment the program counter by /two/. If the top stack frame differs from 0, then the VM does nothing and the program counter will only be incremented by unity.

#+begin_src emacs-lisp :session code
(defun vm//if (stack registers)
  "Pops the top stack frame and increments the program counter by
unity if it is eqaul to 0, otherwise do nothing."
  (if (equal (pop stack) 0)
      (vm//increment-pc registers 1))
  stack)
#+end_src

#+RESULTS:
: vm//if

We can now add the ~IF~ and ~RJUMP~ instructions on our VM:

#+begin_src emacs-lisp :session code
(defun vm//main (instructions &optional log)
  (let ((stack '())
        (registers (list 
                    (cons 'eax  0)
                    (cons 'ebx  0)
                    (cons 'ecx  0)   ; heap pointer
                    (cons 'pc  0)))  ; program counter
        (ram (make-list 10 0)))
    (while (< (alist-get 'pc registers) (length instructions))
      (let* ((instruction (nth (alist-get 'pc registers) instructions))
             (key (nth 0 instruction))
             (val (nth 1 instruction)))
        (if (equal key "RJUMP") ; relative jump
            (vm//increment-pc registers val))
        (if (equal key "IF")    ; conditional statement
            (setq stack (vm//if stack registers)))
        (if (equal key "READ_RAM")
            (vm//read-ram registers ram))
        (if (equal key "WRITE_RAM")
            (setq ram (vm//write-ram registers ram)))
        (if (equal key "LOAD")
            (setq stack (vm//load stack registers)))
        (if (equal key "STORE")
            (setq stack (vm//store stack registers)))
        (if (equal key "PUSH")
            (setq stack (vm//push stack val)))
        (if (equal key "ADD")
            (setq stack (vm//op stack '+)))
        (if (equal key "SUB")
            (setq stack (vm//op stack '-)))
        (if log
            (message "%s %s %s" instruction stack registers)))
      (vm//increment-pc registers 1))
    `(,stack ,registers, ram)))
#+end_src

#+RESULTS:
: vm//main

Let's test these new instructions. We'll try both /if/ cases to demonstrate how it works. The snippet bellow pushes 0 and calls ~IF~. We therefore expect that condition to fail and hence skip the ~("PUSH" 10)~ instruction leading to a final stack equal to ~(20)~.

#+begin_src emacs-lisp :session code
(vm//main '(("PUSH" 0)
            ("IF")
            ("RJUMP" 1) ; if true
            ("RJUMP" 1) ; else
            ("PUSH" 10)
            ("PUSH" 20)))
#+end_src

#+RESULTS:
|        20 |           |           |          |   |   |   |   |   |   |
| (eax . 0) | (ebx . 0) | (ecx . 0) | (pc . 6) |   |   |   |   |   |   |
|         0 |         0 |         0 |        0 | 0 | 0 | 0 | 0 | 0 | 0 |
 
Testing with a True condition, we now do not skip over the ~("PUSH" 10)~ instruction leading to a stack equal to ~(20 10)~ as expected.

#+begin_src emacs-lisp :session code
(vm//main '(("PUSH" 1)
            ("IF")
            ("RJUMP" 1) ; if true
            ("RJUMP" 1) ; else
            ("PUSH" 10)
            ("PUSH" 20)))
#+end_src

#+RESULTS:
|        20 |        10 |           |          |   |   |   |   |   |   |
| (eax . 0) | (ebx . 0) | (ecx . 0) | (pc . 6) |   |   |   |   |   |   |
|         0 |         0 |         0 |        0 | 0 | 0 | 0 | 0 | 0 | 0 |
 
** Compiling

#+begin_src emacs-lisp :session code
(defun compiler//loop-start (instructions jump-length)
  "Check that value at pc (stored in ecx) is not 0.
If it is, then jump by jump-length to matching ]
otherwise, jump over the else instruction to the loop body."
  (push-instruction '("PUSH" ecx))
  (push-instruction '("LOAD"))
  (push-instruction '("PUSH" eax))
  (push-instruction '("STORE"))
  (push-instruction '("READ_RAM"))
  (push-instruction '("PUSH" eax))
  (push-instruction '("LOAD"))
  (push-instruction '("IF"))
  (push-instruction '("RJUMP" 1))
  (push-instruction `("RJUMP" ,(+ 1 jump-length)))
  instructions)

(defun compiler//loop-end (instructions jump-length)
  "Loop back to the start of the loop. It uses a relative jump backwards
with length equal to that of the loop body (jump-length) added to then
loop head code (added by compiler//loop-start)"
  (let ((loop-head-length -11))  ; number of instructions in loop head
    (push-instruction `("RJUMP" ,(+ loop-head-length (- jump-length)))))
  instructions)

(defun find-matching-char (tokens open-char close-char current-pos)
  "Finds the position in an array of chars of the matching characer."
  (let ((counter 0)
        (return-value 0))
    (dolist (el (nthcdr current-pos tokens))
      (if (equal 0 return-value)
          (progn (if (equal el open-char)
                     (setq counter (1+ counter)))
                 (if (equal el close-char)
                     (setq counter (1- counter)))
                 (if (equal counter 0)
                     (setq return-value current-pos)
                   (setq current-pos (1+ current-pos))))))
    return-value))


(defun compiler//loop (code tokens instructions current-pos)
  "Idea:
- keep a record of loop beginnig because we'll need it for the jump
- get value in ram at addr stored in pc and check if 0
  + if 0 then  jump to end of loop location
  + if not call compiler//compile at current-pos+1"
  (let ((start-pos current-pos)
        (matching-pos (find-matching-char tokens "[" "]" current-pos))
        (current-token (nth current-pos tokens))
        (middle-instructions '()))
      (setq middle-instructions (nconc middle-instructions
                                       (compiler//compile
                                        (cl-subseq code
                                                   current-pos
                                                   (1- matching-pos))
                                        nil)))
    (setq instructions (compiler//loop-start instructions
                                             (length middle-instructions)))
    (setq instructions (nconc instructions middle-instructions))
    (setq instructions (compiler//loop-end instructions
                                           (length middle-instructions))))
  instructions)
#+end_src

#+RESULTS:
: compiler//loop
 
#+begin_src emacs-lisp :session code
(defun compiler//compile (code include-init-code)
  "Compiles a brainfuck code string. If this function is called
recursively, set include-init-code to t in the first call and to
nil and all subsequent calls."
  (let ((tokens (lexer//lex code))
        (instructions '())
        (current-pos 0))
    (if include-init-code
        (setq instructions (compiler//init-code instructions)))
    (while (< current-pos (length tokens))
      (let ((el (nth current-pos tokens)))
        (if (equal el "[")
            (progn
              (setq instructions (compiler//loop code
                                                 tokens
                                                 instructions
                                                 current-pos))
              (setq current-pos (find-matching-char tokens "[" "]" current-pos))))
        (if (equal el ">")
            (setq instructions (compiler//increment-pc instructions 1)))
        (if (equal el "<")
            (setq instructions (compiler//increment-pc instructions -1)))
        (if (equal el "-")
            (setq instructions (compiler//increment-value instructions -1)))
        (if (equal el "+")
            (setq instructions (compiler//increment-value instructions 1))))
      (setq current-pos (1+ current-pos)))
    instructions))
#+end_src

#+RESULTS:
: compiler//compile

#+begin_src emacs-lisp :session code
(vm//main (compiler//compile "++>++<[->+<]" t))
#+end_src

#+RESULTS:
| (eax . 0) | (ebx . 4) | (ecx . 0) | (pc . 134) |   |   |   |   |   |   |
|         0 |         4 |         0 |          0 | 0 | 0 | 0 | 0 | 0 | 0 |

* Part V: Adding the Brainfuck stdout instruction, ~.~

** VM modifications
   
We'll need to add a variable to our ~vm//main~ function that can store ~stdout~, we'll initialize it as the empty string. The instruction ~APPEND_STDOUT~ will allow us to push, character by character, to this stdout string:

#+begin_src emacs-lisp :session code
(defun vm//main (instructions &optional log)
  (let ((stack '())
        (registers (list
                    (cons 'eax nil)
                    (cons 'ebx nil)
                    (cons 'ecx nil)
                    (cons 'pc  0)))
        (ram (make-list 10 0))
        (stdout ""))  ; This is the variable that will contain the standart output
    (while (< (alist-get 'pc registers) (length instructions))
      (let* ((elt (nth (alist-get 'pc registers) instructions))
             (key (nth 0 elt))
             (val (nth 1 elt)))
        (if (equal key "APPEND_STDOUT")
            (setq stdout (vm//append-stdout stdout registers)))
        (if (equal key "READ_RAM")
            (vm//read-ram registers ram))
        (if (equal key "WRITE_RAM")
            (setq ram (vm//write-ram registers ram)))
        (if (equal key "LOAD")
            (setq stack (vm//load stack registers)))
        (if (equal key "STORE")
            (setq stack (vm//store stack registers)))
        (if (equal key "RJUMP")
            (vm//increment-pc registers val))
        (if (equal key "IF")
            (setq stack (vm//if stack registers)))
        (if (equal key "PUSH")
            (setq stack (vm//push stack val)))
        (if (equal key "SUB")
            (setq stack (vm//op stack '-)))
        (if (equal key "ADD")
            (setq stack (vm//op stack '+)))
        (if log
            (message "%s %s %s %s" elt stack registers ram)))
      (vm//increment-pc registers 1))
    `(,stdout ,stack ,registers ,ram)))
#+end_src

#+RESULTS:
: vm//main

#+begin_src emacs-lisp :session code
(vm//main '(("PUSH" 70)
            ("PUSH" eax)
            ("STORE")
            ("APPEND_STDOUT")))
#+end_src

#+RESULTS:
| F | nil | ((eax . 70) (ebx) (ecx) (pc . 4)) | (0 0 0 0 0 0 0 0 0 0) |

** Compiling

#+begin_src emacs-lisp :session code
(defun compiler//append-stdout (instructions)
  "Appends the char in pc (stored in ecx) to stdout.

It works as follows:
- store the pc from ecx to eax
- call the READ_RAM instruction which reads ram at the
  address stored in eax and writes the result in eax.
- call the APPEND_STDOUT instruction, which writes to
  stdout the ascii code stored in eax."
  (push-instruction '("PUSH" ecx))
  (push-instruction '("LOAD"))
  (push-instruction '("PUSH" eax))
  (push-instruction '("STORE"))
  (push-instruction '("READ_RAM"))
  (push-instruction '("APPEND_STDOUT"))
  instructions)
#+end_src

#+RESULTS:
: compiler//append-stdout
  
#+begin_src emacs-lisp :session code
(defun compiler//compile (code include-init-code)
  "Compiles a brainfuck code string. If this function is called
recursively, set include-init-code to t in the first call and to
nil and all subsequent calls."
  (let ((tokens (lexer//lex code))
        (instructions '())
        (current-pos 0))
    (if include-init-code
        (setq instructions (compiler//init-code instructions)))
    (while (< current-pos (length tokens))
      (let ((el (nth current-pos tokens)))
        (if (equal el "[")
            (progn
              (setq instructions (compiler//loop code
                                                 tokens
                                                 instructions
                                                 current-pos))
              (setq current-pos (find-matching-char tokens "[" "]" current-pos))))
        (if (equal el ".")
            (setq instructions (compiler//append-stdout instructions)))
        (if (equal el ">")
            (setq instructions (compiler//increment-pc instructions 1)))
        (if (equal el "<")
            (setq instructions (compiler//increment-pc instructions -1)))
        (if (equal el "-")
            (setq instructions (compiler//increment-value instructions -1)))
        (if (equal el "+")
            (setq instructions (compiler//increment-value instructions 1))))
      (setq current-pos (1+ current-pos)))
    instructions))
#+end_src

#+RESULTS:
: compiler//compile

Finally, we can compile the Hello World example taken from Wikipedia's Brainfuck English entry and verify that it runs properly:

#+begin_src emacs-lisp :session code
(setq src "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.")
(vm//main (compiler//compile src t) nil) ; "prints Hello World!"
#+end_src

#+RESULTS:
| Hello World! |                                               |                             |
| nil          | ((eax . 10) (ebx . 10) (ecx . 6) (pc . 1246)) | (0 0 72 100 87 33 10 0 0 0) |
